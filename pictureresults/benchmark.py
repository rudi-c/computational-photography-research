#!/usr/bin/python

# Reads decision trees generated by Weka and evaluate how quickly and how
# accurately they can find peaks.

import getopt
import json
import os
import sys

from scene      import *
from coarsefine import *
from rtools     import *
import featuresturn     
import featuresleftright

def less(a, b):
    return a < b

def less_or_equal(a, b):
    return a <= b

def greater(a, b):
    return a > b

def greater_or_equal(a, b):
    return a >= b

def equals(a, b):
    return a == b

comparator_map = { "<" : less, "<=" : less_or_equal, 
                   ">" : greater, ">=" : greater_or_equal,
                   "=" : equals }

def make_key(direction, initial_pos, current_pos):
    return direction + "-" + str(initial_pos) + "-" + str(current_pos)

class Evaluator:

    def __init__(self, left_right_tree, action_tree, step_size, scene,
                 perfect_classification):
        self.left_right_tree = left_right_tree
        self.action_tree = action_tree
        self.step_size = step_size
        self.scene = scene
        self.status = [ "none" ] * scene.measuresCount
        self.result = [ -1 ] * scene.measuresCount
        self.visitedPositions = [ [] for pos in scene.measuresValues ]
        if perfect_classification is None:
            self.perfect_classification = None
        else:
            self.perfect_classification = \
                perfect_classification[scene.fileName]

    def _walk_left_fine(self, lens_pos, count=1):
        for i in range(0, count):
            visitedPositions = self.visitedPositions[lens_pos]
            visitedPositions.append(max(0, min(visitedPositions[-1] - 1,
                self.scene.measuresCount)))

    def _walk_left_coarse(self, lens_pos, count=1):
        for i in range(0, count):
            visitedPositions = self.visitedPositions[lens_pos]
            visitedPositions.append(max(0, min(visitedPositions[-1] - 8,
                self.scene.measuresCount)))

    def _walk_right_fine(self, lens_pos, count=1):
        for i in range(0, count):
            visitedPositions = self.visitedPositions[lens_pos]
            visitedPositions.append(max(0, min(visitedPositions[-1] + 1,
                self.scene.measuresCount)))

    def _walk_right_coarse(self, lens_pos, count=1):
        for i in range(0, count):
            visitedPositions = self.visitedPositions[lens_pos]
            visitedPositions.append(max(0, min(visitedPositions[-1] + 8,
                self.scene.measuresCount)))

    def _walk_fine(self, lens_pos, direction, count=1):
        if direction in ("left", -1):
            self._walk_left_fine(lens_pos, count)
        elif direction in ("right", +1):
            self._walk_right_fine(lens_pos, count)
        else:
            assert False, direction

    def _walk_coarse(self, lens_pos, direction, count=1):
        if direction in ("left", -1):
            self._walk_left_coarse(lens_pos, count)
        elif direction in ("right", +1):
            self._walk_right_coarse(lens_pos, count)
        else:
            assert False, direction

    def _go_to_max(self, lens_pos, lens_positions):
        current_pos = lens_positions[-1]
        maximum_pos = 0
        max_value = 0
        for pos in lens_positions:
            if self.scene.measuresValues[pos] > max_value:
                max_value = self.scene.measuresValues[pos]
                maximum_pos = pos

        direction = "left" if maximum_pos < current_pos else "right"
        rev_direction = "left" if maximum_pos >= current_pos else "right"

        # Find minimum number of coarse and fine steps needed to go back to
        # the maximum point.
        distance = abs(current_pos - maximum_pos)
        coarse_steps = distance / 8
        self._walk_coarse(lens_pos, direction, coarse_steps)

        remainder = distance % 8
        if remainder <= 4:
            fine_steps = remainder
            self._walk_fine(lens_pos, direction, fine_steps)
        else:
            self._walk_coarse(lens_pos, direction, 1)
            fine_steps = 8 - remainder
            self._walk_fine(lens_pos, rev_direction, fine_steps)

        self.status[lens_pos] = "foundmax"
        self.result[lens_pos] = maximum_pos

        assert self.visitedPositions[lens_pos][-1] == maximum_pos

    def _sweep(self, direction, initial_positions):
        # Sweep the lens in one direction.
        assert abs(direction) == 1

        scene = self.scene

        lens_positions = list(initial_positions)
        current_pos = lens_positions[-1]
        previously_coarse_step = True
        dir_str = "left" if direction == -1 else "right"

        while current_pos > 0 and current_pos < scene.measuresCount - 1:
            # Determine next step size.
            if previously_coarse_step:
                coarse_now = coarse_if_previously_coarse(
                    scene.measuresValues[current_pos],
                    scene.measuresValues[lens_positions[-2]],
                    scene.measuresValues[lens_positions[-3]])
            else:
                coarse_now = coarse_if_previously_fine(
                    scene.measuresValues[current_pos],
                    scene.measuresValues[lens_positions[-2]],
                    scene.measuresValues[lens_positions[-3]])

            # Move the lens forward.
            if coarse_now:
                current_pos = min(scene.measuresCount - 1, 
                                  max(0, current_pos + direction * 8))
            else:
                current_pos = min(scene.measuresCount - 1, 
                                  max(0, current_pos + direction))
            lens_positions.append(current_pos)
            previously_coarse_step = coarse_now
       
            if self.perfect_classification is None:
                # Obtain the ML classification at the new lens position.
                feature_args = { "focus_values" : self.scene.measuresValues,
                                 "lens_positions" : lens_positions,
                                 "total_positions" : self.scene.measuresCount }
                classification = evaluate_tree(self.action_tree, feature_args)
            else:
                classification = self.perfect_classification[make_key(
                    dir_str, lens_positions[0], current_pos)]

            if classification != "continue":
                assert classification == "turn_peak" or    \
                       classification == "backtrack"
                return classification, lens_positions

        # TODO: What should be the default action when an edge is reached?
        return "backtrack", lens_positions

    def _backtrack(self, lens_pos, current_lens_pos):
        """From the current lens position, go back to the lens position we
        were at before and look on the other side."""
        distance_from_initial = abs(lens_pos - current_lens_pos)

        previous_direction_was_left = current_lens_pos < lens_pos

        # We need to reinitialize the list of lens positions used as a feature
        # during the sweep algorithm, to avoid mixing it with the positions
        # of the previous sweep. 
        initial_positions = [lens_pos - self.step_size * 2, 
                             lens_pos - self.step_size, lens_pos]
        if previous_direction_was_left:
            # Go right this time
            new_direction = +1
        else:
            # Go left this time
            new_direction = -1
            initial_positions.reverse()

        # Need to go back to where we were initially at the start of the sweep.
        # It's fine if we overshoot it a little bit if it saves some steps.

        coarse_steps = distance_from_initial / 8
        self._walk_coarse(lens_pos, new_direction, coarse_steps)

        # An extra distance that coarse steps won't reach exactly
        remainder = distance_from_initial % 8
        if remainder > 4:
            # Take more fine steps to reach initial position.
            self._walk_fine(lens_pos, new_direction, 8 - remainder)
        else:
            # Take one big coarse step, which will overshoot a bit.
            self._walk_coarse(lens_pos, new_direction, 1)
            initial_positions.append(self.visitedPositions[lens_pos][-1])

        result, positions = self._sweep(new_direction, initial_positions)

        self.visitedPositions[lens_pos].extend(
            positions[len(initial_positions):])

        if result == "turn_peak":
            self._go_to_max(lens_pos, positions)
        elif result == "backtrack":
            # If we need to backtrack a second time, we failed.
            self.status[lens_pos] = "failed"
        else:
            assert False

    def _evaluate_at_position(self, lens_pos):
        # Decide initial direction in which to look.
        first  = self.scene.measuresValues[lens_pos - self.step_size * 2]
        second = self.scene.measuresValues[lens_pos - self.step_size]
        third  = self.scene.measuresValues[lens_pos]
        feature_args = { "first" : first, "second" : second, 
                         "third" : third, "lens_pos" : lens_pos }
        direction = evaluate_tree(self.left_right_tree, feature_args)

        initial_positions = [lens_pos - self.step_size * 2, 
                             lens_pos - self.step_size, lens_pos]
        self.visitedPositions[lens_pos].extend(initial_positions)
        if direction == "left":
            initial_positions.reverse()
            result, positions = self._sweep(-1, initial_positions)
        elif direction == "right":
            result, positions = self._sweep(+1, initial_positions)
        else:
            assert False

        self.visitedPositions[lens_pos].extend(
            positions[len(initial_positions):])

        if result == "turn_peak":
            self._go_to_max(lens_pos, positions)
        elif result == "backtrack":
            self._backtrack(lens_pos, positions[-1])
        else:
            assert False

    def evaluate(self):
        """For every scene and every lens position, run a simulation and
        store the statistics."""
        for lens_pos in range(self.step_size * 2, self.scene.measuresCount):
            self._evaluate_at_position(lens_pos)


def benchmark_scenes(left_right_tree, action_tree, step_size, scenes,
                     perfect_classification):
    evaluators = [ Evaluator(left_right_tree, action_tree, step_size, scene,
                             perfect_classification) 
                   for scene in scenes ]
    for evaluator in evaluators:
        evaluator.evaluate()

    for evaluator in evaluators:
        scene = evaluator.scene
        count_failed = sum([ s == "failed" for s in evaluator.status])
        count_foundmax = sum([ s == "foundmax" for s in evaluator.status])
        sum_distances = sum( 
            [ scene.distance_to_closest_peak(result)
              for (result, status) in zip(evaluator.result, evaluator.status)
              if status == "foundmax" ] )
        sum_steps = sum([ len(vps) for vps in evaluator.visitedPositions ])

        print "%s | %d failed | %d success | %.3f avg distance to peak | " \
              "%.3f avg steps " % (scene.fileName, count_failed, 
              count_foundmax, float(sum_distances) / count_foundmax,
              float(sum_steps) / evaluator.scene.measuresCount)


def benchmark_specific(left_right_tree, action_tree, step_size, 
                       scenes, specific_scene, perfect_classification):
    for scene in scenes:
        if scene.fileName == specific_scene:
            evaluator = Evaluator(left_right_tree, action_tree, 
                                  step_size, scene, perfect_classification)
            evaluator.evaluate()

            for lens_pos in range(0, scene.measuresCount):
                print_R_script(scene, lens_pos, 
                    evaluator.visitedPositions[lens_pos],
                    evaluator.status[lens_pos],
                    evaluator.result[lens_pos])


def print_R_script(scene, lens_pos, visitedPositions, status, result):

    print "# %s at %d, %s\n" % (scene.fileName, lens_pos, status)

    # Some R functions for plotting.
    print_set_window_division(1, 1)
    print "library(scales)" # for alpha blending

    print_plot_focus_measures(scene.measuresValues)

    xs = visitedPositions
    ys = [ float(i) / max(10, len(visitedPositions))
           for i in range(0, len(visitedPositions)) ]

    print_plot_point_pairs(xs, ys, 25, "blue", "blue", True)

    if status == "foundmax":
        print "segments(%d, 0.0, %d, 1.0)" % (result, result)

    print "\n# Plot me!\n"


def read_decision_tree(filename, features):
    """Transform a JSON representation of the decision tree into one that can
    be used directly (with lambdas for feature evaluation and comparison)"""
    def parse_tree(json_tree):
        if isinstance(json_tree, str) or isinstance(json_tree, unicode):
            # Reached leaf.
            return str(json_tree)
        else:
            feature, children = json_tree
        if not features.has_key(feature):
            raise Exception("Feature %s not found." % feature)
        return (features[feature], 
                [ (comparator_map[comparator], value, parse_tree(subtree))
                  for comparator, value, subtree in children ])

    if os.path.isfile(filename):
        f = open(filename)
        lines = f.readlines()
        f.close()
    else:
        print "Error : File %s not found!" % filename
        sys.exit(1)

    json_tree = json.loads("".join(lines))
    return parse_tree(json_tree)


def evaluate_tree(tree, feature_args):
    if isinstance(tree, str):
        # Reached leaf.
        return tree
    if isinstance(tree, unicode):
        raise Exception("Expecting non-unicode string")

    function, children = tree
    node_evaluation = function(**feature_args)
    for comparator, value, subtree in children:
        if isinstance(value, list):
            # Handle ranges of values.
            if value[0] < node_evaluation <= value[1]:
                return evaluate_tree(subtree, feature_args)
        elif comparator(node_evaluation, value):
            return evaluate_tree(subtree, feature_args)
    raise Exception("No match in tree for evaluated featured!")


def load_classifications(filename):
    try:
        f = open(filename)
        lines = f.readlines()
        f.close()
    except IOError:
        raise Exception("File " + filename + " not found.")
    return json.loads("".join(lines))


def print_script_usage():
   print  """Script usage : ./makegroundtruthcomparison.py 
             --left-right-tree=<decision tree for deciding left vs right>
             --action-tree=<decision tree for deciding action to take>]
             [-d, --double-step <double step size used>]
             [--specific-scene=<a scene's filename, will print R script]
             [--perfect-file=<use classification from file instead of tree>]"""


def main(argv):

    if not os.path.isdir(scenes_folder):
        print scenes_folder + " folder not found."
        return

    # Parse script arguments
    try:
        opts, args = getopt.getopt(argv, "d",
            ["left-right-tree=", "action-tree=", "double-step",
             "specific-scene=", "perfect-file="])
    except getopt.GetoptError:
        print_script_usage()
        sys.exit(2)

    step_size = 1
    left_right_tree = None
    action_tree = None
    specific_scene = None
    perfect_classification = None

    for opt, arg in opts:
        if opt == "--double-step":
            step_size = 2
        elif opt == "--left-right-tree":
            features = { name : function 
                for name, _, function in featuresleftright.all_features() }
            left_right_tree = read_decision_tree(arg, features)
        elif opt == "--action-tree":
            features = { name : function 
                for name, function in featuresturn.all_features() }
            action_tree = read_decision_tree(arg, features)
        elif opt == "--specific-scene":
            specific_scene = arg
        elif opt == "--perfect-file":
            perfect_classification = load_classifications(arg)
        else:
            print_script_usage()
            sys.exit(2)

    if (left_right_tree == None or action_tree == None) and \
            perfect_classification == None:
        print_script_usage()
        sys.exit(2)

    scenes = load_scenes()
    load_maxima_into_measures(scenes)

    if specific_scene == None:
        benchmark_scenes(left_right_tree, action_tree, step_size, scenes,
            perfect_classification)
    else:
        benchmark_specific(left_right_tree, action_tree, step_size, scenes,
                           specific_scene, perfect_classification)


main(sys.argv[1:])